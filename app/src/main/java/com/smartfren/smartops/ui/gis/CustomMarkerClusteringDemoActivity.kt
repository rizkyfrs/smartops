/**
 * DO NOT EDIT THIS FILE.
 *
 *
 * This source code was autogenerated from source code within the `demo/src/gms` directory
 * and is not intended for modifications. If any edits should be made, please do so in the
 * corresponding file under the `demo/src/gms` directory.
 */
/*
 * Copyright 2013 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.smartfren.smartops.ui.gis

import com.smartfren.smartops.ui.gis.BaseDemoActivity
import com.google.maps.android.clustering.ClusterManager.OnClusterClickListener
import com.google.maps.android.clustering.ClusterManager.OnClusterInfoWindowClickListener
import com.google.maps.android.clustering.ClusterManager.OnClusterItemClickListener
import com.google.maps.android.clustering.ClusterManager.OnClusterItemInfoWindowClickListener
import com.google.maps.android.clustering.ClusterManager
import com.google.maps.android.clustering.view.DefaultClusterRenderer
import com.google.maps.android.ui.IconGenerator
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import com.google.maps.android.clustering.Cluster
import com.smartfren.smartops.ui.gis.MultiDrawable
import com.smartfren.smartops.R
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.Toast
import com.google.android.gms.maps.CameraUpdateFactory
import com.google.android.gms.maps.model.*
import com.google.maps.android.clustering.ClusterItem
import com.smartfren.smartops.ui.gis.CustomMarkerClusteringDemoActivity.PersonRenderer
import com.smartfren.smartops.ui.gis.model.Person
import java.lang.Exception
import java.util.*

/**
 * Demonstrates heavy customisation of the look of rendered clusters.
 */
class CustomMarkerClusteringDemoActivity : BaseDemoActivity(), OnClusterClickListener<Person>, OnClusterInfoWindowClickListener<Person?>,
    OnClusterItemClickListener<Person?>, OnClusterItemInfoWindowClickListener<Person?> {
    private var mClusterManager: ClusterManager<Person>? = null
    private val mRandom = Random(1984)

    /**
     * Draws profile photos inside markers (using IconGenerator).
     * When there are multiple people in the cluster, draw multiple photos (using MultiDrawable).
     */
    private inner class PersonRenderer : DefaultClusterRenderer<Person>(applicationContext, map, mClusterManager) {
        private val mIconGenerator = IconGenerator(applicationContext)
        private val mClusterIconGenerator = IconGenerator(applicationContext)
        private val mImageView: ImageView
        private val mClusterImageView: ImageView
        private val mDimension: Int
        override fun onBeforeClusterItemRendered(person: Person, markerOptions: MarkerOptions) {
            // Draw a single person - show their profile photo and set the info window to show their name
            markerOptions
                .icon(getItemIcon(person))
                .title(person.name)
        }

        override fun onClusterItemUpdated(person: Person, marker: Marker) {
            // Same implementation as onBeforeClusterItemRendered() (to update cached markers)
            marker.setIcon(getItemIcon(person))
            marker.title = person.name
        }

        /**
         * Get a descriptor for a single person (i.e., a marker outside a cluster) from their
         * profile photo to be used for a marker icon
         *
         * @param person person to return an BitmapDescriptor for
         * @return the person's profile photo as a BitmapDescriptor
         */
        private fun getItemIcon(person: Person): BitmapDescriptor {
            mImageView.setImageResource(person.profilePhoto)
            val icon = mIconGenerator.makeIcon()
            return BitmapDescriptorFactory.fromBitmap(icon)
        }

        override fun onBeforeClusterRendered(cluster: Cluster<Person>, markerOptions: MarkerOptions) {
            // Draw multiple people.
            // Note: this method runs on the UI thread. Don't spend too much time in here (like in this example).
            markerOptions.icon(getClusterIcon(cluster))
        }

        override fun onClusterUpdated(cluster: Cluster<Person>, marker: Marker) {
            // Same implementation as onBeforeClusterRendered() (to update cached markers)
            marker.setIcon(getClusterIcon(cluster))
        }

        /**
         * Get a descriptor for multiple people (a cluster) to be used for a marker icon. Note: this
         * method runs on the UI thread. Don't spend too much time in here (like in this example).
         *
         * @param cluster cluster to draw a BitmapDescriptor for
         * @return a BitmapDescriptor representing a cluster
         */
        private fun getClusterIcon(cluster: Cluster<Person>): BitmapDescriptor {
            val profilePhotos: MutableList<Drawable> = ArrayList(Math.min(4, cluster.size))
            val width = mDimension
            val height = mDimension
            for (p in cluster.items) {
                // Draw 4 at most.
                if (profilePhotos.size == 4) break
                val drawable = resources.getDrawable(p.profilePhoto)
                drawable.setBounds(0, 0, width, height)
                profilePhotos.add(drawable)
            }
            val multiDrawable = MultiDrawable(profilePhotos)
            multiDrawable.setBounds(0, 0, width, height)
            mClusterImageView.setImageDrawable(multiDrawable)
            val icon = mClusterIconGenerator.makeIcon(cluster.size.toString())
            return BitmapDescriptorFactory.fromBitmap(icon)
        }

        override fun shouldRenderAsCluster(cluster: Cluster<Person>): Boolean {
            // Always render clusters.
            return cluster.size > 1
        }

        init {
            val multiProfile = layoutInflater.inflate(R.layout.multi_profile, null)
            mClusterIconGenerator.setContentView(multiProfile)
            mClusterImageView = multiProfile.findViewById(R.id.image)
            mImageView = ImageView(applicationContext)
            mDimension = 50
            mImageView.layoutParams = ViewGroup.LayoutParams(mDimension, mDimension)
            val padding = 2
            mImageView.setPadding(padding, padding, padding, padding)
            mIconGenerator.setContentView(mImageView)
        }
    }

    override fun onClusterClick(cluster: Cluster<Person>): Boolean {
        // Show a toast with some info when the cluster is clicked.
        val firstName = cluster.items.iterator().next().name
        Toast.makeText(this, cluster.size.toString() + " (including " + firstName + ")", Toast.LENGTH_SHORT).show()

        // Zoom in the cluster. Need to create LatLngBounds and including all the cluster items
        // inside of bounds, then animate to center of the bounds.

        // Create the builder to collect all essential cluster items for the bounds.
        val builder = LatLngBounds.builder()
        for (item in cluster.items) {
            builder.include(item.position)
        }
        // Get the LatLngBounds
        val bounds = builder.build()

        // Animate camera to the bounds
        try {
            map.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, 100))
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return true
    }

    override fun onClusterInfoWindowClick(cluster: Cluster<Person?>) {
        // Does nothing, but you could go to a list of the users.
    }

    override fun onClusterItemClick(item: Person?): Boolean {
        // Does nothing, but you could go into the user's profile page, for example.
        return false
    }

    override fun onClusterItemInfoWindowClick(item: Person?) {
        // Does nothing, but you could go into the user's profile page, for example.
    }

    override fun startDemo(isRestore: Boolean) {
        if (!isRestore) {
            val indonesiaBounds = LatLngBounds(
                LatLng((-5.968225391239664), 89.4923492893149), // SW bounds
                LatLng((1.5134520668060687), 125.9669586643149)  // NE bounds
            )
//            map.moveCamera(CameraUpdateFactory.newLatLngZoom(LatLng(51.503186, -0.126446), 9.5f))
            map.moveCamera(CameraUpdateFactory.newLatLngZoom(indonesiaBounds.center, 3f))
        }
        mClusterManager = ClusterManager(this, map)
        mClusterManager!!.renderer = PersonRenderer()
        map.setOnCameraIdleListener(mClusterManager)
        map.setOnMarkerClickListener(mClusterManager)
        map.setOnInfoWindowClickListener(mClusterManager)
        mClusterManager!!.setOnClusterClickListener(this)
        mClusterManager!!.setOnClusterInfoWindowClickListener(this)
        mClusterManager!!.setOnClusterItemClickListener(this)
        mClusterManager!!.setOnClusterItemInfoWindowClickListener(this)
        addItems()
        mClusterManager!!.cluster()
    }

    private fun addItems() {
        mClusterManager!!.addItem(Person(LatLng(-6.31416000, 106.66632000), "ZJKT_4002", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.30188000, 106.67785000), "ZJKT2_6633", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.31218000, 106.69103000), "ZJKT2_4542", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.28514389, 106.66552806), "NJKTIBS_0322", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.29641750, 106.67079028), "NJKTLEZ_0023", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.28113000, 106.65872000), "ZJKT_4988", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.29169000, 106.69506000), "ZJKT_5316", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.29909000, 106.68314000), "ZJKT_6362", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.28207000, 106.68065000), "ZJKT_5030", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.27952000, 106.69167000), "ZJKT_6413", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.32843000, 106.67481000), "ZJKT_6466", R.drawable.ic_alarm))
        mClusterManager!!.addItem(Person(LatLng(-6.34232000, 106.70363000), "ZJKT_6421", R.drawable.ic_alarm))
    }

    private fun position(): LatLng {
        return LatLng(random(51.6723432, 51.38494009999999), random(0.148271, -0.3514683))
    }

    private fun random(min: Double, max: Double): Double {
        return mRandom.nextDouble() * (max - min) + min
    }
}